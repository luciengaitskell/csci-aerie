\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb,latexsym,amsmath,epsfig,amsthm}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}


\title{Midterm 1}
\author{Lucien Gaitskell}  % not supposed to in actual submission 
\date{January 2021}

\begin{document}

\maketitle

\section{Problem 1}

\begin{enumerate}[label=(\alph*)]
    \item The algorithm is written in psuedocode in \textbf{Algorithm \ref{differencealg}}
    \begin{algorithm}
        \caption{Maximum difference of $n \times n$ matrix }
        \label{differencealg}
        \begin{tabular}{r l}
            \hspace*{\algorithmicindent} \textbf{Input}: & $A = n \times n$ table of numbers \\
            \hspace*{\algorithmicindent} \textbf{Output}:& $d=$ maximum difference in $A$ \\
                                                         %& $l=$ minimum value in $A[1..n-1, 1..n-1]$
        \end{tabular}
        
        \begin{algorithmic}[1] % The number tells where the line numbering should start
            \Function{Maximize}{$A$} \Comment{given $A$ and $n \times n$ matrix}
                \If{$n == 1$} \Comment{base case}
                    \State \Return $0, A[1,1]$
                    \item[] \Comment{difference of element to itself and smallest value ($A[1,1]$)}
                \EndIf
                \item[]
                
                \State $d, l \gets \Call{Maximize}{A[1..n-1, 1..n-1]}$ \Comment{get data for sub-matrix}
                \State $l_h \gets l$ \Comment{Create minimum value var for new vertical values}
                \State $l_v \gets l$ \Comment{Create minimum value var for new horizontal values}

                \item[]

                \For{$i = 1\to n, j = n-1$} \Comment{Horizontal operations}
                    \State $l_h \gets min(A[i,j], l_h)$ \Comment{Save smallest value for horizontal}
                    \State $d \gets max(A[i,j] - l_h, d)$ \Comment{Save maximum difference}
                \EndFor
                \item[]
                \For{$j = 1\to n-1, i = n$} \Comment{Vertical operations}
                    \State $l_v \gets min(A[i,j], l_v)$ \Comment{Save smallest value for vertical}
                    \State $d \gets max(A[i,j] - l_v, d)$ \Comment{Save maximum difference}
                \EndFor

                \item[]
                \State $l \gets min(l_v, l_h, A[n,n])$ \Comment{Save smallest value for for corner $(n,n)$}
                \State $d \gets max(A[n,n] - l, d)$ \Comment{Save maximum difference}

                \State \Return $d, l$ \Comment{maximum difference and mininum value}
            \EndFunction
            \item[]
            \Function{DifferenceMaximize}{$A$} \Comment{The sorted form of A}
                \State $d, l \gets \Call{Maximize}{A}$ \Comment{Run maximize function}
                \State \Return $d$  \Comment{Return only desired value}
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    % This algo doesn't account for the possibility that optimal solution is A[i,j]-A[i, j-1]
    %   possibly would need to make recursion at a finer resolution

    \item Algorithm \ref{differencealg} visits every possible $A[i, j]$
        and compares it's difference with the smallest $A[c,d]$ in the subarray $A[1..i, 1..j]$.
        Therefore, this algorithm must give the optimal value of $A[i, j]-A[c, d]$.
    \item As algorithm \ref{differencealg} visits every possible $A[i, j]$ only once,
        it takes $O(n^2)$ time.
        Although structured as a recursion, each parent step relys on data from the subsequent step
        only computing for the missing new $A[i, j]$ on $A[1..n, 1..n]$ using existing data from $A[1..n-1, 1..n-1]$.
\end{enumerate}

\section{Problem 2}

\begin{enumerate}[label=(\alph*)]
    \item The algorithm is written in psuedocode in \textbf{Algorithm \ref{majorityalg}}
    \begin{algorithm}
        \caption{Majority element in an array}
        \label{majorityalg}

        \begin{tabular}{r l}
            \hspace*{\algorithmicindent} \textbf{Input}:  & $A[1..n] = n$ length array of non-ordered elements \\
            \hspace*{\algorithmicindent} \textbf{Output}: & $d=$ majority element value in $A$ or $\varnothing$ if none \\
        \end{tabular}

        \begin{algorithmic}[1]
            \Function{MajorityValue}{$A$} \Comment{$A$ an array of length $n$}
                \If{$n==0$}
                    \State \Return $\varnothing$
                \EndIf
                \If{$n==1$}
                    \State \Return $A[1]$
                \EndIf
                \item[]
                \State $v \gets A[1]$ \Comment{Selected value from array}
                \State $c \gets 0$ \Comment{Counter for local occurrence of $v$}
                \item[]
                \For{$v_i$ in $A[2..n]$}
                    \If{$v_i = v$} \Comment{Iterate counter if values match}
                        \State $c \gets c+1$
                    \Else
                        \If{$c > 0$} \Comment{If multiple prior occurrences only decrement}
                            \State $c \gets c-1$
                        \Else \Comment{$c=0, set new value$}
                            \State $v=v_i$
                        \EndIf
                    \EndIf
                \EndFor
                \item[]
                \State $c_g \gets 0$ \Comment{Counter for global occurrences of $v$}
                \For{$v_i$ in $A[1..n]$}
                    \If{$v=v_i$}
                        \State $c_g \gets c_g + 1$
                    \EndIf
                \EndFor
                \item[]
                \If{$c_g > \lfloor n/2 \rfloor$} \Comment{Return if element is majority}
                    \State \Return $v$
                \Else \Comment{There is no majority}
                    \State \Return $\varnothing$
                \EndIf
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \item \textbf{Proof:}
    \begin{itemize}
        \item Case 1: \emph{$A$ has no majority}\\
        Therefore, regardless of $v$, the selected value, the global occurrences count
        from the second loop will never exceed $\lfloor n/2 \rfloor$, by the definition
        of majority element.

        \item Case 2: \emph{$A$ has a majority} \\
        Given each value $a_i$ of $u$ unique elements in $A$, there are corresponding occurrence
        counts of $c_i$. Let the majority element value be $a_m$ and count be $c_m$.
        Therefore, $c_m > \sum_{i=1}^{m} c_i + \sum_{i=m}^{u} c_i$. \\
        In the worst case, $c_m = \lfloor n/2 \rfloor +1$, and each occurrence is interleaved
        between all other elements, elements of value $a_m$ must start and finish the array.
        Therefore, the algorithm will return $a_m$, correctly.        
    \end{itemize}

    \item \textbf{Algorithm \ref{majorityalg}} operates over the full length $n$ of $A$ twice, serially.
    Each operation within the loops take $O(1)$ constant time.
    Therefore the runtime is $O(n) + O(n) = O(n)$.
\end{enumerate}

\section{Problem 3}
\begin{enumerate}[label=(\alph*)]
    \item The algorithm is written in psuedocode in \textbf{Algorithm \ref{hotelalg}}
    \begin{algorithm}
        \caption{Optimal hotel path for Bilbo}
        \label{hotelalg}

        \begin{tabular}{r l}
            \hspace*{\algorithmicindent} \textbf{Inputs}:    & $D[1..n] = n$ length array of distances to next hotel. \\
                                                            & $R[1..n] = n$ length array of ranges from each hotel \\
                                                            & ($D[n] = R[n] = \varnothing$ represents the end) \\
            \hspace*{\algorithmicindent} \textbf{Output}:   & $P[1..m] = m$ length array of the path containing \\
                                                            & each hotel index from A in the path \\
        \end{tabular}

        \begin{algorithmic}[1]
            \Function{HotelPath}{$D[1..n], R[1..n]$}
                \State $i_c = 1$            \Comment{Set current hotel index to first}
                \State $P \gets [i_c]$ \Comment{Create path starting at current hotel}
                \item[]
                \While{$i_c < n$}           \Comment{Continue until at end of journey}
                    \If{$D[i_c] > R[i_c]$}        \Comment{Path impossible if next hotel exceeds range}
                        \State \Return $\varnothing$
                    \Else                   \Comment{Default choosing subsequent hotel}
                        \State $i_{next} \gets i_c + 1]$
                        \State $t_{next} \gets D[i_c] + D[i_{next}]$    \Comment{Total range from hotel $i_c$}
                        \State $d_t \gets D[i_c] + D[i_{next}]$     \Comment{Distance counter}
                    \EndIf
                    \item[]
                    \State $i_s = i_c+2$    \Comment{Select next available hotel}
                    \While{$R[i_c] \geq d_t$ and $i_s \leq n$}  \Comment{Operate until past list or range}
                        \If{$R[i_s]==D[i_s]==\varnothing$}      \Comment{If possible, go to end}
                            \State $i_{next} = i_s$
                            \State $t_{next} = t_s$
                        \Else   \Comment{Select new hotel and test cumulative range}
                            \State $t_s \gets d_t + R[i_s]$
                            \If{$t_{next} < t_s$}   \Comment{Save if cumulative range is larger}
                                \State $i_{next} = i_s$
                                \State $t_{next} = t_s$
                            \EndIf
                        \EndIf
                        \item[]
                        \State $i_s \gets i_s + 1$  \Comment{Select next hotel to test}
                    \EndWhile
                    \item[]
                    \State $P \gets P + i_{next}$   \Comment{Save next hotel to path}
                    \State $i_c = i_{next}$         \Comment{Set current hotel to prior next hotel}
                \EndWhile
                \item[]
                \State \Return $P$  \Comment{Greedily selected optimal path}
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \item The optimal solution to the problem will visit the fewest hotels,
        and therefore allow Bilbo to make his journey in the least time.
        This is a great use case for a greedy algorithm.
        Given a starting hotel $h_a$, there is a set of hotels $A$
        within range of $h_a$. Each hotel $h_i$ in $A$ has a distance from
        $h_a$ of $d_i$. The range from $h_i$ is $r_i$. The maximum potential
        range of $h_i$ is $t_i = d_i + r_i$.

        Repeatidly selecting the hotel $h_o$ with the maximum $t_o$ will allow
        Bilbo to travel the most distance every day.
        Therefore, on average, Bilbo will travel farther per day and will
        take an optimal path.

        The algorithm will return a null path if at one point no subsequent
        hotel could be reached. In this case the path is impossible.

    \item The algorithm operates using two loops. However, the outer
        loop only iterates once for every hotel $h \in P$,
        given $P$ the set of selected hotels in Bilbos path.
        The inner loop iterates once for every hotel $h \notin P$.
        All other operations within the loops take constant $O(1)$ time.
        These two sets encompasses the set of all hotels
        $H = (h \in P) \cup (h \notin P)$, of length $n$.
        Therefore the runtime is $O(n) \cdot O(1) = O(n)$.
\end{enumerate}

\end{document}
