\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb,latexsym,amsmath,epsfig,amsthm}


\title{Homework 1}
\author{Lucien Gaitskell}
\date{October 2020}

\begin{document}

\maketitle

\section{Problem 1}

\subsection{List (with Big-O)}

Calculate Big-O of each given equation.

\begin{align}
    6n\log n &= O(n\log n) \\
    2^{100} &= O(1) \\
    \log \log n &= O(\log \log n) \\
    \log^2 n &= O(\log^2 n) \\
    2^{2^{n}} &= O(2^{2^{n}}) \\
    \lceil \sqrt{n} \rceil &= O(n^{\frac{1}{2}}) \\
    n^{0.01} &= O(n^{\frac{1}{100}}) \\
    \frac{1}{n} &= O(n^{-1}) \\
    4n^{\frac{3}{2}} &= O(n^{\frac{3}{2}}) \\
    3n^{0.5} &= O(n^{\frac{1}{2}}) \\
    5n &= O(n)\\
    \lfloor 2n \log^2n \rfloor &= O(n \log^2n) \\
    2^n &= O(2^n) \\
    n \log_4 n &= O(n \log n) \\
    4^n &= O(4^n) \\
    n^3 &= O(n^3) \\
    n^2 \log n &= O(n^2 \log n) \\
    \sqrt{\log n} &= O(\sqrt{\log n})
\end{align}

\subsection{Growth Rate Classifications}

Group each equation by their Big-O classifications.

\begin{center}
    \small From smallest to largest.
\end{center}

\begin{align*}
    \intertext{\subsubsection*{Inverse}}
    \frac{1}{n} &= O(n^{-1})
    \intertext{\subsubsection*{Constant}}
    2^{100} &= O(1)
    \intertext{\subsubsection*{Polylogarithmic}}
    \sqrt{\log n} &= O(\log^{\frac{1}{2}}n) \\
    \log^2 n &= O(\log^2 n)
    \intertext{\subsubsection*{Logarithmic}}
    \log \log n &= O(\log \log n)
    \intertext{\subsubsection*{Root}}
    3n^{0.5} &= O(n^{\frac{1}{2}}) \\
    \lceil \sqrt{n} \rceil &= O(n^{\frac{1}{2}}) \\
    n^{0.01} &= O(n^{\frac{1}{100}})
    \intertext{\subsubsection*{Linear}}
    5n &= O(n) \\
    \intertext{\subsubsection*{Linearithmic}}
    \lfloor 2n \log^2n \rfloor &= O(n \log^2n) \\
    n \log_4 n &= O(n \log n) \\
    6n\log n &= O(n\log n)
    \intertext{\subsubsection*{Quadratic}}
    4n^{\frac{3}{2}} &= O(n^{\frac{3}{2}}) \\
    n^2 \log n &= O(n^2 \log n)
    \intertext{\subsubsection*{Cubic}}
    n^3 &= O(n^3) \\
    \intertext{\subsubsection*{Exponential}}
    4^n &= O(4^n) \\
    2^n &= O(2^n) \\
    2^{2^{n}} &= O(2^{2^{n}})
\end{align*}

\subsection{Final List}

Final organization of equations based on Big-O size.

\setcounter{equation}{0}
\begin{align}
    \frac{1}{n} &= O(n^{-1}) \\
    2^{100} &= O(1) \\
    \log \log n &= O(\log \log n) \\
    \sqrt{\log n} &= O(\log^{\frac{1}{2}}n) \\
    \log^2 n &= O(\log^2 n) \\
    n^{0.01} &= O(n^{\frac{1}{100}}) \\
    3n^{0.5} =
    \lceil \sqrt{n} \rceil &= O(n^{\frac{1}{2}}) \\
    5n &= O(n) \\
    6n\log n =
    n \log_4 n &= O(n \log n) \\
    \lfloor 2n \log^2n \rfloor &= O(n \log^2n) \\
    4n^{\frac{3}{2}} &= O(n^{\frac{3}{2}}) \\
    n^2 \log n &= O(n^2 \log n) \\
    n^3 &= O(n^3) \\
    2^n &= O(2^n) \\
    4^n &= O(4^n) \\
    2^{2^{n}} &= O(2^{2^{n}})
\end{align}

\section{Problem 2}
\subsection{Question (a)}

\begin{align*}
    T(n) &= \sum_{j=1}^{n} \left(
                \sum_{k=j}^{n}\left(
                    1 + \sum_{i=j}^{k}\left(3\right)
                \right)
            \right) + 2 \\
         &= \sum_{j=1}^{n} \left(
                \sum_{k=j}^{n}\left(
                    1 + ((k-j) \cdot 3)
                \right)
            \right) + 2 \\ 
        &= \sum_{j=1}^{n} \left(
                \sum_{k=j}^{n}\left(
                    1 + 3k - 3j
                \right)
            \right) + 2 \\
        &= \sum_{j=1}^{n} \left(
                \sum_{k=j}^{n}\left(
                    3k
                \right) +
                \sum_{k=j}^{n}\left(
                    1 - 3j
                \right)
            \right) + 2 \\
        &= \sum_{j=1}^{n} \left(
                3 \sum_{k=j}^{n}
                    k
                 +
                (n-j) \cdot (1 - 3j)
            \right) + 2 \\
        &= \sum_{j=1}^{n} \left(
                3 \cdot \frac{n-j}{2} \cdot (n + j)
                 +
                (n-j) \cdot (1 - 3j)
            \right) + 2 \\
        &= \sum_{j=1}^{n} \left(
                (n-j) \cdot \left(
                    \frac{3}{2} \cdot (n + j)
                    + 1 - 3j
                \right)
            \right) + 2 \\
        &= \sum_{j=1}^{n} \left(
                (n-j) \cdot \left(
                    \frac{3}{2} n
                    - \frac{3}{2}j
                    + 1
                \right)
            \right) + 2 \\
        &= \sum_{j=1}^{n} \left(
                \frac{3}{2} n^2
                + \frac{3}{2} j^2
                - 3 nj
                + n
                - j
            \right) + 2 \\
        &= \sum_{j=1}^{n} \left(
                \frac{3}{2} n^2
                + n
            \right)
            +
            \frac{3}{2}
            \sum_{j=1}^{n}
                j^2
            -
            (3n + 1)
            \sum_{j=1}^{n}
                j
            + 2 \\
        &= n \left(
                \frac{3}{2} n^2
                + n
            \right)
            +
            \frac{3n (n+1) (2n+1)}{12}
            -
            \frac{(3n + 1) (n-1)(n+1)}{2}
            + 2 \\
        &= \left(
                \frac{3n^3}{2}
                + n ^2
            \right)
            + \left(
                \frac{n^3}{2} + \frac{3n^2}{4} + \frac{n}{4}
            \right)
            - \left(
                \frac{3n^3}{2} + \frac{n^2}{2} + \frac{3n}{2} + \frac{1}{2}
            \right)
            + 2 \\
        &= \frac{n^3}{2}
            + \frac{5n^2}{4}
            - \frac{5n}{4}
            + \frac{3}{2}
\end{align*}

\subsection{Question (b)}
\begin{align*}
    T(n) &\geq cn^3 \hspace{2mm} \text{for} \hspace{1mm} n \geq n_0\\
    T(n) = \frac{n^3}{2}
    + \frac{5n^2}{4}
    - \frac{5n}{4}
    + \frac{3}{2}
    &\geq cn^3 \\
    T^{\prime}(n) = \frac{1}{2}
    + \frac{5}{4n}
    - \frac{5}{4n^2}
    + \frac{3}{2n^3}
    &\geq c \\
    \lim_{n \to \inf} T^{\prime}(n) &= \frac{1}{2} \\
    \therefore
    T(n) &= O(n^3)
\end{align*}

\section{Problem 3}
\subsection*{Structure}

Use a \textbf{`mid'-heap} structure, where the median element is stored at the root.
This structure holds for each subsequent sub-tree, with smaller values on the left and larger on the right.

In the case where there is an even number of elements, the root node will be null.
The median operations will then yield the two medians.
Therefore, there will be a value to keep track of the number of elements.

This pasta data structure will also occupy $O(n)$ space.

\subsection*{Runtimes}
\begin{itemize}
    \item The $insert(x)$ operation will take $O(\log n)$ time due to downheap and maintain heap structure.
        In an empty heap, the insert will create the first node.
        If there are nodes, an insert will require a series of swaps at each level.
        At each level, only one of the two edges is followed and therefore will only operate $O(\log n)$ times.
        The node count value will be incremented.
    \item The $removeMedian()$ operation removes either the root node, for odd node count, or both subsequent nodes for even counts.
        This will take $O(\log n)$ time due to upheap, which is necessary to maintain the heap structure.
        A series of swaps will be required to fill the hole(s) left by the removed node(s).
        For each removed node, only one of the two edges is followed at each level and therefore will only operate $O(\log n)$ times.
        The node count value will be decremented, either once or twice accordingly.
    \item The $median()$ operation will take $O(1)$. If top node has a value, return its value.
        If there is no top node value, then return the two values of subsequent nodes.
        If there are no nodes, then return a null value.
\end{itemize}


\section{Problem 4}
\subsection{Part a}

Use a Binary Search Tree to hold each person with their given position value.
The nodes will be sorted by the position value in the line of each person.
This will make it far more efficient when looking to find the subsequent person in line.

\subsubsection{Operations}
\begin{enumerate}
    \item The $enter(p)$ operation will add an additional node to the BST.
        In order to maintain structure, this will have a runtime of $O(log n)$,
        as at each node only one side of the tree is followed to restructure.
    \item The $exit(p)$ operation will remove a node from the BST.
        In order to maintain structure, this will have a runtime of $O(log n)$,
        as at each node only one side of the tree is followed to restructure.
    \item The $throw(p)$ operation will take $O(log n)$ time.
        This is because first the person at $p$ has to be found in the BST.
        Then, finding the subsequent person can be done in constant time,
        as they are just the next node to the right.
\end{enumerate}

This structure will occupy $O(n)$ space, as one node will be created for each person.

\subsection{Part b}

Use a Binary Search Tree similar to \emph{Part (a)}.
However, the nodes will also maintain an extra value containing the maximum height in its subtree.
This addition will make it far more efficient when looking to find the subsequent person in line of at least a specific height.

\subsubsection{Operations}
\begin{enumerate}
    \item The $enter(p, h)$ operation will be nearly identical to above.
        However, an additional step will be added at each traversed node,
        to update the maximum height of each subtree, moving up and down the tree.
        This is a constant time addition, and therefore will also have a runtime of $O(log n)$.
    \item The $exit(p)$ operation will be nearly identical to above.
        However, an additional step will be added at each traversed node,
        to update the maximum height of each subtree, moving up and down the tree.
        This is also a constant time addition, and therefore will have a runtime of $O(log n)$.
    \item The $throw(p, t)$ operation will be similar to that above.
        However, after finding finding the person who throws the tomato,
        the search will have to traverse up and back down the tree.
        The initial traverse up and to the right, will be to find the closest subtree
        with a maximum hight $\geq t$.
        Subsequently, the tree will then be traversed back down, initially trying the left
        and subsequently right nodes, based on an acceptable max height value.
        Once a leaf is found, or the children have max height values $< t$, then that person
        is returned as the recipient of the tomato.
        As these vertical traversals are done sequentially, and only along one edge of the BST,
        the addition to runtime is $O(log n)$, which resolves overall to $O(log n)$.
\end{enumerate}

This structure is still a BST, with one extra value per node.
As a result, the structure will still occupy $O(n)$ space, as only one node is needed for each person.

\end{document}
