\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb,latexsym,amsmath,epsfig,amsthm}
\usepackage{enumitem}
\usepackage{ulem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{makecell}


\title{Homework 2}
\author{Lucien Gaitskell}
\date{December 2020}

\begin{document}

\maketitle

\section{Problem 1}

$S = [34,32,21,9,43,35,42,15,1,4,17,20,8,42,27]$

\begin{itemize}
    \item $\textproc{DeterministicSelect}(S, 8)$ \\
    Baby sequences: $[[34,32,21,9,43],[35,42,15,1,4],[17,20,8,42,27]]$ \\
    Baby medians: $[32,15,20]$

    \begin{itemize}
        \item $\textproc{DeterministicSelect}([32, 15, 20],2)$ \\
        Baby sequences: $[[32,15,20]]$ \\
        Baby medians: $[20]$

        \begin{itemize}
            \item $\textproc{DeterministicSelect}([20],1)$ \\
            return $20$

        \end{itemize}
        $x = 20 $ \\
        $L = [15] $ \\
        $E = [20] $ \\
        $G = [32] $ \\
        return $20$

    \end{itemize}

    $x = 20$ \\
    $L = [1,4,8,9,15,17]$ \\
    $E = [20]$ \\
    $G = [34,32,21,43,35,42,42,27]$

    \begin{itemize}
        \item $\textproc{DeterministicSelect}([34,32,21,43,35,42,42,27],1)$ \\
        Baby sequences: $[[34,32,21,43,35],[32,42,42,27]]$ \\
        Baby median: $[34, 42]$
        \begin{itemize}
            \item $\textproc{DeterministicSelect}([34, 42],1)$ \\
            Baby sequences: $[[34, 42]]$ \\
            Baby medians: $[34]$
            \begin{itemize}
                \item $\textproc{DeterministicSelect}([34],1)$ \\
                return $34$
            \end{itemize}
            
            $x = 34$ \\
            $L = []$ \\
            $E = [34]$ \\
            $G = [42]$
            
            return $34$
        \end{itemize}

        $x = 34$ \\
        $L = [21, 32, 27]$ \\
        $E = [34]$ \\
        $G = [43, 35, 42, 42]$

        \begin{itemize}
            \item $\textproc{DeterministicSelect}([21, 32, 27],1)$ \\
            Baby sequences: $[[21, 32, 27]]$ \\
            Baby medians: $[27]$
            \begin{itemize}
                \item $\textproc{DeterministicSelect}([27],1)$ \\
                return $27$
            \end{itemize}

            $x = 27$ \\
            $L = [21]$ \\
            $E = [27]$ \\
            $G = [32]$

            \begin{itemize}
                \item $\textproc{DeterministicSelect}([21], 1)$ \\
                return $21$
            \end{itemize}
            return $21$           
        \end{itemize}
        
        return $21$
    \end{itemize}

    return $21$
\end{itemize}


\section{Problem 2}

\subsection{Part 1}

Assume the day begins at $d_o$ and ends as $d_e$.

\begin{enumerate}[label=(\alph*)]
    \item \textbf{Counterexample:} Suppose workshop $1$, such that $s_1 = d_o$
    and $t_1 = d_e$. Suppose there is another workshop ($2$) that starts a minute
    after workshop $1$ and ends during workshop $1$. $\therefore s_2=s_1 + 1, t_2=x$
    such that $s_1+1 < x < t_1$. Suppose another workshop $3$, such that 
    $s_3 = x, t_3 = d_e$.

    This greedy algorithm will select workshop $1$ due to the earlier starting time.
    However, selecting workshop $1$ will cause workshop $2$ and $3$ to be removed.
    Therefore, only one workshop will be selected to visit,
    despite the opportunity to visit two during the day.

    \item \textbf{Proof:} When selecting the next latest event, any overlaps are removed.
    Therefore, If this other workshop which started earlier was kept, than the current
    worshop could not be visited. In this case, it is safer to chose the later workshop,
    as it can not cause any other conflicts. Therefore, this algorithm will give you the
    most number of workshops able to visit.

    \item \textbf{Counterexample:} Suppose three workshops:
        \begin{enumerate}[label=\arabic*]
            \item Length x
            \item Length x+1
            \item Length x+1
        \end{enumerate}

        Suppose workshop $2$ and $3$ immediately follow each other, and workshop $1$ overlaps both.
        Workshop $1$ will be selected first, and others will be excluded.
        However, selecting workshop $2$ and $3$ is the more optimal solution.
\end{enumerate}

\subsection{Part 2}

\begin{enumerate}
    \item Let $S$ be the list of stands
    \item Let $V$ contain each visit
    \item Calculate necessary trips, given stands $S$
    \item Sort stands by open time in increasing order
    \item Start with stands of smallest lengths open, and find all overlapping workshops
        % THIS IS A BIT WOOLY
    \item Combine all overlapping workshops into one visit, add to $V$ and remove from $S$
    \item Continue until $S$ is empty
    \item Return $V$
\end{enumerate}

This algorithm must return the optimal solution, as it prioritizes the least flexible stands.
Each greedy step will not compromise any following step, as each subsequent stand is more flexible.

\section{Problem 3}

\begin{enumerate}[label=\alph*)]
    \item There are only three possible groupings of staff members within 10 miles of each other.
        It is important to note that two of these groups share a member.
        Regardless, there will need to be three stations in a configuration such as:
        \begin{enumerate}[label={Station \arabic*:}, leftmargin=*]
            \item 5
            \item 15
            \item 30
        \end{enumerate}
    \item Process:
        \begin{enumerate}[label=\arabic*:]
            \item Sort N in increasing order
            \item Pick next smallest staff member
            \item Add all subsequent stations within 10 miles
            \item Place station in middle of the group
            \item Continue until all staff members processed.
            \item \textbf{Return} set.
        \end{enumerate}
        
        By first sorting the set, and then beginning from the smaller side,
        the station must be $\geq x_1$ for $x_i$ the position of next smallest
        distance staff $i$. Therefore, all the other staff within $10$ to the right
        can share a station. This continues until all staff members are visited.
        This must be the most efficient, as as a bare minimum, every staff member
        requires a station, however can be grouped to save on overall count.

        The runtime will be $O(n \log{n} + n) = O(n \log{n})$.
        This is because a sort is first necessary ($O(n \log{n})$)
        and then grouping the staff members subsequently
        take a full iteration through the set ($O(n)$).

    \item In this case, the staff members will still be sorted by distance along $\ell$.
        The search will have to be performed until the next staff member
        has $\Delta \ell > 10$. However, not all staff members within this range will be
        grouped. A staff member will be in range if their
        distance $d \leq \sqrt{(\Delta x-5)^2 + y^2}$.
        The grouped staff members will be removed from $N$, and then the algorithm
        will start again at the beginning of the remainin sorted set.
        
    \item Yes, this algorithm does depend on a linear arrangement of staff.
        For example, if a all the staff are arranged on a spiral, beginning at an origin
        and with a  radius always smaller than $5$. The optimal solution is a single station
        at the origin. However, the algorithm would only consider along the line, and would
        add multiple stations.
\end{enumerate}

\section{Problem 4}

\begin{enumerate}
    \item $T(i,j)$
        \textbf{Base cases}:
        \begin{enumerate}
            \item if $i = 0 \therefore \text{return } j $ representing length of $Y[1..j]$
            \item if $j = 0 \therefore \text{return } i $ representing length of $X[1..i]$
        \end{enumerate}

        if last characters match: $X[i] = Y[j] = A \therefore subcost = 0 \text{ else } subcost = 1$

        \textbf{Recursive step} - return minimum of:
        \begin{enumerate}
            \item $T(i-1, j-1) + subcost$ (substitution, if necessary)
            \item $T(i-1, j) + 1$ (delete from X)
            \item $T(i, j-1) + 1$ (insertion as not in X)
        \end{enumerate}
    
        The base cases are inherently true, as only insertions can occur for (a)
        and deletions for (b).
        Each recursive step represents the three possible operations for each sub-string,
        as the values in the string can only be inserted, deleted, or substituted.
        
        Therefore, as each step and the base cases are true, the the algorithm holds.

    \item \textbf{$T$ Table: }\\
        \begin{tabular}{c||c|c|c|c|c|c|c|c|c|}
            & \thead{0} & \thead{P\\1} & \thead{O\\2} & \thead{R\\3} & \thead{K\\4} & \thead{C\\5} & \thead{H\\6} & \thead{O\\7} & \thead{P\\8} \\
            \hline
            \hline
            0   & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
            \hline
            T 1 & 1 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
            \hline
            O 2 & 2 & 2 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
            \hline
            N 3 & 3 & 3 & 2 & 2 & 3 & 4 & 5 & 6 & 7 \\
            \hline
            K 4 & 4 & 4 & 3 & 3 & 2 & 3 & 4 & 5 & 6 \\
            \hline
            A 5 & 5 & 5 & 4 & 4 & 3 & 3 & 4 & 5 & 6 \\
            \hline
            T 6 & 6 & 6 & 5 & 5 & 4 & 4 & 4 & 5 & 6 \\
            \hline
            S 7 & 7 & 7 & 6 & 6 & 5 & 5 & 5 & 5 & 6 \\
            \hline
            U 8 & 8 & 8 & 7 & 7 & 6 & 6 & 6 & 6 & \textbf{6} \\
            \hline
        \end{tabular}

        I first filled out the row along T/$1$ and column below P/$1$,
        following the base cases where $i = 0$ and $j = 0$.
        Subsequently, I computed the other cells starting at $i,j=(1,1)$,
        requiring that the three relative cells to the top, top left, and left were also filled.
        I propagated down each subsequent column and row until reaching $i,j=(8,8)$.
    
    
    \item The issue will arise if the two strings are: \emph{ABCDE} and \emph{FGAHI}.
        This is because the altered value will become an issue, as $T(1, 3) = 3$ and $\not= 2$
        as a substition is taking place. However, the algorithm wll instead favor a deletion.
        Otherwise, if $X[1]\not=Y[3]$, then the initializaton error would not cause an issue,
        as deletion should be favored.

\end{enumerate}

\section{Problem 5}

\begin{enumerate}[label=\alph*.]
    \item Algorithm \ref{marginalgo} given $S$ an array of words in the sentence

    % Instead build backwards?
    \begin{algorithm}
        \caption{Three-split merge sort}
        \label{marginalgo}
        \begin{algorithmic}[1] % The number tells where the line numbering should start
            \Procedure{Margin}{$S, m, l$} \Comment{Cost for sentence $S$ in margin size $m$ given existing line length $l$}
                \If{$isempty(S)$}
                    \State \textbf{return} 0
                \EndIf
                \item[]
                \State $case1 \gets (len(L)-m)^2 + $ \Call{Margin}{$S[2...], m, 0$}
                \Comment{Start new line. Cost is this line plus all subsequent.}
                \item[]
                \State $case2 \gets $ \Call{Margin}{$S[2...], m, (l+1+len(S[1]))$}
                \Comment{Continue this line including cost of this word and space.}
                \item[]
                \State \textbf{return} $min(case1, case2)$
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

    \item This algorithm will attempt all possible combinations of newlines between words, selecting the minimum paths.
        Therefore, this algorithm must be correct as it tries all combinations.
    \item The runtime will be $O(2^n)$ for number of words $n$, as for each word calls the same function twice
        on a slightly smaller set. Therefore, each word causes twice the subsequent operations to occur and corresponds
        to a doubling of runtime for each word, hence the exponential.
\end{enumerate}

\end{document}
